### **PSI** (0.1-ALPHA)
**Processed Source Instructions**

*By Arshavir Mirzakhani*

### Sections

 1. Objective
 2. Comments
 3. Program Structure
 4. Label Definitions
 5. Types and Values
 6. Local Variables
 7. Basic Instructions
 8. Functions and Arguments 
 9. System Calls and Program Calls
 10. Program Requirements

### Objective

PSI is a language for defining a program's behavior. It is designed to be both human and machine readable, while being able to translate seamlessly into other code, such as assembly or low-level op-codes.

### Comments

The `//` symbol marks the rest of the line as comment:

```psilang
// this is an comment
```

You can also make multi-line comments by writting `/*` at beginning and `*/` at end:

```psilang
/*
this is an multi line comment
*/
```

### Program Structure

Every PSI program must have the following structure:

```psilang
module program;
entry main;

main {

}
```
- `module` the program name
- `entry` the program entry label
- `main { ... }` definition of entry label

### Label Definitions

Each label can contain its own definitions. a definition is basically an block instructions:

```psilang
main {
    instruction1; 
    instruction2;
    instruction3;
    ...
}
```

### Types and Values

PSI distinguishes between values and types.
Values represent literal data (numbers, floats, booleans).
Types describe how values are interpreted and processed by a backend.
PSI itself does not enforce size, alignment, or representation, these are defined by the backend for each type.

#### Values

In PSI values can be represented in multiple ways

##### Integer

a value that represents a whole number. can be prefixed with `+` for positive values or `-` for nagtive values.
```psilang
13
-7
+1102
```
Non-integer values can also be expressed in hexadecimal, octal or binary:
```psilang
// hexadecimal with prefix 0x
0xDEADBEEF
0xdeadbeef

// octal with prefix 0o
0o01234567
0o755

// binary with prefix 0b
0b10010101
```

##### Float

a value that represents a floating-point value:
```psilang
0.7
3.14
130.99
```

##### Boolean

a value that can only be `true` or `false`.

#### Types

In PSI types determine how value of variables should be processed. Types are always prefixed with `$` symbol.
```psilang
$int
$float
$custom_type
```


### Local Variables

Local variables are prefixed with the symbol `%`. They hold a value and can be used as argument of instructions:
```psilang
main {
    // a is an local variable
    instruction %a;
}
```
Local variables name cannot begin with numbers:
```psilang
// valid
%a
%hello_var2

// invalid
%1
%2_var
```

### Basic Instructions

PSI comes with some built-in instructions that can be used for programs. Instructions can only be used inside definitions;

#### MOV

`mov` instruction copies a value to an local variable with an type:

```psilang
mov <type of dest> <dest> <src>;
```

example:
```psilang
main {
    mov $int %a 7; // copy value 7 to %a with type $int
    mov $int %b %a; // copy value of %a to %b with type $int
    mov $float %c %a; // copy value if %a to %c with type $float 
}
```

#### ADD

`add` instruction copies addition of two value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.

```psilang
add <result> <operand1> <operand2>;
```

example:
```psilang
main {
    add %a 3 2; // add 3 to 2 and copy the result to %a
    add %b %a -5; // add value of %a to -5 and copy the result to %b
}
```

#### SUB

`sub` instruction copies subtraction of two value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.


```psilang
sub <result> <operand1> <operand2>;
```

example:
```psilang
main {
    sub %a 3 2; // subtract 3 by 2 and copy the result to %a
    sub %b %a 5; // subtract value of %a by 5 and copy the result to %b
}
```

#### CEQ 

`ceq` instruction compares two value and checks if they are equal or not. If equal copy `true` into result, otherwise copy `false` into result 

**Note:** the result value is always an boolean.

```psilang
ceq <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    ceq %r %a 5; // value of %r will be 'true'
}
```

#### CNQ 

`cnq` instruction compares two value and checks if they are equal or not. If not equal copy `true` into result, otherwise copy `false` into result 

**Note:** the result value is always an boolean.

```psilang
cnq <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    cnq %r %a 1; // value of %r will be 'true'
}
```

#### CGT

`cgt` instruction compares two value and checks if value of first operand is greater than value of second operand. If the value of fisrt operand is greater than value of second operand, copy `true` into result, otherwise copy `false` into result

**Note:** the result value is always an boolean.

```psilang
cgt <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    cgt %r %a 3; // value of %r will be 'true'
}
```

#### CLT

`clt` instruction compares two value and checks if value of first operand is lesser than value of second operand. If the value of fisrt operand is lesser than value of second operand, copy `true` into result, otherwise copy `false` into result

**Note:** the result value is always an boolean.

```psilang
clt <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    clt %r %a 7; // value of %r will be 'true'
}
```

#### AND

`and` instruction takes two boolean values and checks if both are `true`. If both are `true`, copy `true` into result, otherwise copy `false` into result.

**Note:** the result value is always an boolean.

```psilang
and <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $bool %a `true`; 
    and %r %a true; // value of %r will be 'true'
}
```

#### OR

`and` instruction takes two boolean values and checks if one of then is `true` or not. If both or one of them is `true`, copy `true` into result, otherwise copy `false` into result.

**Note:** the result value is always an boolean.

```psilang
or <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $bool %a `false`; 
    or %r %a true; // value of %r will be 'true'
}
```

#### JMP

`jmp` instruction tells backend to jump to another label.

```psilang
jmp <label>;
```

example:
```psilang
main {
    jmp test;
}

test {
    add 2 3;
}
```

#### JMT

`jmt` instruction tells backend to jump to another label if given value is true.

**Note:** The given value must be an boolean

```psilang
jmt <label> <value>;
```

example:
```psilang
main {
    mov $int %a 5;
    ceq %r %a 5;
    jmt test %r; // the jump happens
}

test {
    add 2 3;
}
```


<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <link rel="stylesheet" href="../style.css">
</head>

<script src="../script.js" type="text/javascript"></script>