### **PSI** (0.1-ALPHA)
**Processed Source Instructions**

*By Arshavir Mirzakhani*

### Sections

 1. Objective
 2. Comments
 3. Program Structure
 4. Label Definitions
 5. Types and Values
 6. Local Variables
 7. Basic Instructions
 8. Functions and Arguments 
 9. System Calls and Program Calls
 10. Program Requirements

### Objective

#### What is PSI?

PSI is a language for defining a program's behavior. It is designed to be both human and machine readable, while being able to translate seamlessly into other code, such as assembly or low-level op-codes.

#### What is a PSI backend?

PSI dosen't do anything by itself. This means PSI requires a backend.

A PSI backend is a program that reads PSI code and does actions based on it.  For example:

- executing PSI instructions
- compiling/translating PSI into other codes

**Important:** A PSI backend **must** follow the specifictions of PSI code and not change the syntax or instructions behaviour's. If it does its no longer an PSI backend

### Comments

The `//` symbol marks the rest of the line as comment:

```psilang
// this is an comment
```

You can also make multi-line comments by writting `/*` at beginning and `*/` at end:

```psilang
/*
this is an multi line comment
*/
```

### Program Structure

Every PSI program must have the following structure:

```psilang
module program;
entry main;

main {

}
```
- `module` the program name
- `entry` the program entry label
- `main { ... }` definition of entry label

### Label Definitions

Each label can contain its own definitions. a definition is basically an block instructions:

```psilang
main {
    instruction1; 
    instruction2;
    instruction3;
    ...
}
```

### Types and Values

PSI distinguishes between values and types.
Values represent literal data (numbers, floats, booleans).
Types describe how values are interpreted and processed by a backend.
PSI itself does not enforce size, alignment, or representation, these are defined by the backend for each type.

#### Values

In PSI values can be represented in multiple ways

##### Integer

a value that represents a whole number. can be prefixed with `+` for positive values or `-` for nagtive values.
```psilang
13
-7
+1102
```
Non-integer values can also be expressed in hexadecimal, octal or binary:
```psilang
// hexadecimal with prefix 0x
0xDEADBEEF
0xdeadbeef

// octal with prefix 0o
0o01234567
0o755

// binary with prefix 0b
0b10010101
```

##### Float

a value that represents a floating-point value:
```psilang
0.7
3.14
130.99
```

##### Boolean

a value that can only be `true` or `false`.

#### Types

In PSI types determine how value of variables should be processed by backend. PSI does not have any builtin types and they must be defined in backend. Types are always prefixed with `$` symbol.
```psilang
$int
$float
$custom_type
```

### Local Variables

Local variables are prefixed with the symbol `%`. They hold a value and can be used as argument of instructions:
```psilang
main {
    // a is an local variable
    instruction %a;
}
```
Local variables name cannot begin with numbers:
```psilang
// valid
%a
%hello_var2

// invalid
%1
%2_var
```

### Basic Instructions

PSI comes with some built-in instructions that can be used for programs. Instructions can only be used inside definitions;

#### MOV

`mov` instruction copies a value to an local variable with an type:

```psilang
mov <type of dest> <dest> <src>;
```

example:
```psilang
main {
    mov $int %a 7; // copy value 7 to %a with type $int
    mov $int %b %a; // copy value of %a to %b with type $int
    mov $float %c %a; // copy value if %a to %c with type $float 
}
```

#### ADD

`add` instruction copies addition of two value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.

```psilang
add <result> <operand1> <operand2>;
```

example:
```psilang
main {
    add %a 3 2; // add 3 to 2 and copy the result to %a
    add %b %a -5; // add value of %a to -5 and copy the result to %b
}
```

#### SUB

`sub` instruction copies subtraction of two value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.


```psilang
sub <result> <operand1> <operand2>;
```

example:
```psilang
main {
    sub %a 3 2; // subtract 3 by 2 and copy the result to %a
    sub %b %a 5; // subtract value of %a by 5 and copy the result to %b
}
```

#### MUL

`mul` instruction copies multiplication of two value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.


```psilang
mul <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mul %a 3 2; // multiply 3 by 2 and copy the result to %a
    mul %b %a 5; // multiply value of %a by 5 and copy the result to %b
}
```

#### DIV

`div` instruction copies diviision of two value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.


```psilang
div <result> <operand1> <operand2>;
```

example:
```psilang
main {
    div %a 4 2; // divide 4 by 2 and copy the result to %a
    div %b %a 2; // divide value of %a by 2 and copy the result to %b
}
```

#### NEG

`neg` instruction copies negative of given value into the result.

**Note:** Instruction result types are determined by the backend based on operand values and expected result.


```psilang
neg <result> <operand>;
```

example:
```psilang
main {
    neg %a 10; // %a will be -10
    neg %b %a; // %b will be 10
}
```

#### CEQ 

`ceq` instruction compares two value and checks if they are equal or not. If equal copy `true` into result, otherwise copy `false` into result 

**Note:** the result value is always an boolean.

```psilang
ceq <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    ceq %r %a 5; // value of %r will be 'true'
}
```

#### CNQ 

`cnq` instruction compares two value and checks if they are equal or not. If not equal copy `true` into result, otherwise copy `false` into result 

**Note:** the result value is always an boolean.

```psilang
cnq <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    cnq %r %a 1; // value of %r will be 'true'
}
```

#### CGT

`cgt` instruction compares two value and checks if value of first operand is greater than value of second operand. If the value of fisrt operand is greater than value of second operand, copy `true` into result, otherwise copy `false` into result

**Note:** the result value is always an boolean.

```psilang
cgt <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    cgt %r %a 3; // value of %r will be 'true'
}
```

#### CLT

`clt` instruction compares two value and checks if value of first operand is lesser than value of second operand. If the value of fisrt operand is lesser than value of second operand, copy `true` into result, otherwise copy `false` into result

**Note:** the result value is always an boolean.

```psilang
clt <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $int %a 5;
    clt %r %a 7; // value of %r will be 'true'
}
```

#### NOT

`not` instruction takes a boolean value and copies the opposite value into the result.

**Note:** the result value is always an boolean.

```psilang
not <result> <operand>;
```

example:
```psilang
main {
    mov $bool %a true; 
    not %b %a; // %b value will be 'false'
}
```

#### AND

`and` instruction takes two boolean values and checks if both are `true`. If both are `true`, copy `true` into result, otherwise copy `false` into result.

**Note:** the result value is always an boolean.

```psilang
and <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $bool %a true; 
    and %r %a true; // value of %r will be 'true'
}
```

#### OR

`and` instruction takes two boolean values and checks if one of them is `true` or not. If both or one of them is `true`, copy `true` into result, otherwise copy `false` into result.

**Note:** the result value is always an boolean.

```psilang
or <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $bool %a `false`; 
    or %r %a true; // value of %r will be 'true'
}
```


#### XOR

`and` instruction takes two boolean values and checks if only one of them is `true` or not. If only one of them is `true`, copy `true` into result, otherwise copy `false` into result.

**Note:** the result value is always an boolean.

```psilang
xor <result> <operand1> <operand2>;
```

example:
```psilang
main {
    mov $bool %a `false`; 
    xor %r %a true; // value of %r will be 'true'
}
```


#### JMP

`jmp` instruction tells backend to jump to another label.

```psilang
jmp <label>;
```

example:
```psilang
main {
    jmp test;
}

test {
    add 2 3;
}
```

#### JMT

`jmt` instruction tells backend to jump to another label if given value is true.

**Note:** The given value must be an boolean

```psilang
jmt <label> <value>;
```

example:
```psilang
main {
    mov $int %a 5;
    ceq %r %a 5;
    jmt test %r; // the jump happens
}

test {
    add 2 3;
}
```

### Functions and Arguments 

#### Functions

In PSI we are able to treat labels as functions. A function is able to be called meaning it dosent need to be jumped to. Functions are able to take values as input and return values.
```psilang
function <return type> <label>;
```

example:
```
function $int test_func;

test_func {
    add %a 2 3;
}
```

#### Returning values

The `ret` instruction takes a value and returns it.

**Note:** the `ret` instruction should be only used inside a label that is defined as an function.

```psilang
ret <value>;
```
example:
```psilang
function $int test_func;

test_func {
    add %a 2 3;
    ret %a; // return's the value of %a
}
```

#### Arguments

Functions can take some arguments as input. In PSI we only need to define arguments type:
```psilang
function <return type> <label> <arg1 type> <arg2 type> ... <argN type>;
```

To access value of arguments inside a label definition, we use the index of that argument prefixed with symbol `!`:
```psilang
!0 // first argument
!1 // second argument
!2 // third argument
```

**Note:** arguments indexing begins from 0.

example:
```psilang
function $int test_func $int $int;

test_func {
    add %a !0 !1; // sum of first two arguments
    ret %a;
}
```

We can also use an variable as index:
```psilang
!%a // get argument at index of value of %a
```

#### Variadic Functions
A variadic function is a function that can take more inputs of same type at the end. To make an variadic function, we prefix the type of variadic values with `?`
```psilang
function <return type> <label> <arg1 type> <arg2 type> ?<variadic type>;
```

To be able to use variadic functions, we need to know how many arguments we have passed to that function. To do that we use the `!!` symbol to obtain the count of passed arguments, and to access them we can use an variable to iterate through each argument.

example:
```psilang
function $int test_func ?$int; // this function can take variable amount of $int at end

test_func {
    mov $int %count !!;
    sub %last_index count 1; // get last argument index
    mov $int val !%last_index; // get the value of last argument
}
```

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <link rel="stylesheet" href="../style.css">
</head>

<script src="../script.js" type="text/javascript"></script>